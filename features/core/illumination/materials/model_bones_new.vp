#version 140

// Attributes
in highp vec4 position;
in mediump vec2 texcoord0;
in mediump vec3 normal;
in highp vec4 weight;
in highp vec4 bone;

// Uniform blocks
uniform vertex_uniforms {
    highp mat4 mtx_world;
    highp mat4 mtx_view;
    highp mat4 mtx_proj;
    highp vec4 animation;
      #include "/features/core/illumination/assets/materials/shadow/shadow_vp_uniforms.glsl"
};

// Texture samplers
uniform highp sampler2D tex_anim;

// Varying outputs
out mediump vec2 var_texcoord0;
out highp vec3 var_world_position;
out mediump vec3 var_world_normal;
out highp vec3 var_camera_position;
out highp vec3 var_view_position;
  #include "/features/core/illumination/assets/materials/shadow/shadow_vp_out.glsl"

#include "/features/core/materials/includes/matrix_utils.glsl"

// Decode matrix element from RGBA-encoded float
highp float DecodeFloatRGBA(highp vec4 rgba) {
    return dot(rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0)) * (128.0 - (-128.0)) + (-128.0);
}

// Reconstruct bone matrix from texture
highp mat4 get_bone_matrix(int idx) {
    highp mat4 mtx_bone;
    float offset = float(idx) * 12.0; // 3x4

    for (int row = 0; row < 3; ++row) {
        vec4 vec;
        for (int col = 0; col < 4; ++col) {
            float tex_offset = offset + float(row * 4 + col);
            vec[col] = DecodeFloatRGBA(texture(tex_anim, vec2(tex_offset * animation.x, animation.y)));
        }
        mtx_bone[row] = vec;
    }

    mtx_bone = mat44_transpose(mtx_bone);
    return mtx_bone;
}

void main() {
    vec4 p = vec4(position.xyz, 1.0);
    vec3 n = normal;

    if (weight.x > 0.0) {
        vec4 resultPos = vec4(0.0);
        vec3 resultNormal = vec3(0.0);
        for (int i = 0; i < 4; i++) {
            if (weight[i] == 0.0) break;
            mat4 m = get_bone_matrix(int(bone[i]));
            resultPos += (m * p) * weight[i];
            resultNormal += (mat3(m) * n) * weight[i];
        }
        p = resultPos;
        n = resultNormal;
    }

    vec4 world_position = mtx_world * vec4(p.xyz, 1.0);
    var_world_position = world_position.xyz;

    vec4 view_position = mtx_view * world_position;
    var_view_position = view_position.xyz;

    var_world_normal = normalize(mat33_transpose(mat43_inverse(mtx_world)) * n);
      #include "/features/core/illumination/assets/materials/shadow/shadow_vp_calculation.glsl"

    mat4 mtx_inv_view = mat4_inverse(mtx_view);
    var_camera_position = (mtx_inv_view * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

    var_texcoord0 = texcoord0;
    gl_Position = mtx_proj * view_position;
}
