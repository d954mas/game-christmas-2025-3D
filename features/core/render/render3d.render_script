local N28S = require "libs.n28s"
local LOG = require "libs.log"
local EVENTS = require "libs.events"
local CAMERAS = require "features.core.camera.cameras_feature"
local GAME = require "game.game_world_3D"
local GUI_RESIZER = require "features.core.gui_resizer"
local FEATURES = require "features.features"
local CONTEXTS = require "libs.contexts_manager"
local IlluminationFeature = require "features.core.illumination.illumination_feature"

local HASH_WINDOW_RESIZED = hash("window_resized")
local TAG = "Render"

local TEMP_V = vmath.vector4()
local TEMP_MATRIX4 = vmath.matrix4()


---@class Render3D
local Render = {}

function Render:init()
	CONTEXTS:register(CONTEXTS.NAMES.RENDER, self)
	self.screen_size = {
		w = nil, h = nil, aspect = nil
	}
	self.config_size = {
		w = render.get_width(),
		h = render.get_height(),
	}
	self.config_size.aspect = self.config_size.w / self.config_size.h

	self.constants = {
		time = vmath.vector4(),
		player_pos_clip = vmath.vector4(),
		player_pos_view = vmath.vector4(),
		clip = vmath.vector4()
	}

	GAME.lights:set_render(self)
	self:init_predicates()
	self:init_draw_opts()
	self.clear = { [graphics.BUFFER_TYPE_COLOR0_BIT] = GAME.lights.fog_color, [graphics.BUFFER_TYPE_DEPTH_BIT] = 1, [graphics.BUFFER_TYPE_STENCIL_BIT] = 0 }
	self.clear_rt = { [graphics.BUFFER_TYPE_COLOR0_BIT] = vmath.vector4(0, 0, 0, 0), [graphics.BUFFER_TYPE_DEPTH_BIT] = 1, [graphics.BUFFER_TYPE_STENCIL_BIT] = 0 }
	self:calculate_screen_size()
	self:window_size_changed()

	self.view = vmath.matrix4()
	self.proj = vmath.matrix4()
	self.frustum = vmath.matrix4()

	_G.RENDER = self
end

function Render:init_draw_opts()
	self.draw_opts = {
		constants = render.constant_buffer(),
		frustum = self.frustum,
		frustum_planes = render.FRUSTUM_PLANES_ALL,
	}
end

function Render:init_predicates()
	self.predicates = {
		tile = render.predicate({ "tile" }),
		gui = render.predicate({ "gui" }),
		gui_world = render.predicate({ "gui_world" }),
		gui_world_font = render.predicate({ "gui_world_font" }),
		model = render.predicate({ "model" }),
		char = render.predicate({ "char" }),
		model_transparent = render.predicate({ "model_transparent" }),
		model_no_shadow = render.predicate({ "model_no_shadow" }),
		arrow = render.predicate({ "arrow" }),
		particles_world = render.predicate({ "particles_world" }),
		sprite_3d = render.predicate({ "sprite_3d" }),
		sprite_glow = render.predicate({ "sprite_glow" }),
		rect_area = render.predicate({ "rect_area" }),
	}
end

function Render:window_size_changed()
	self.gui_proj = vmath.matrix4_orthographic(0, self.screen_size.w, 0, self.screen_size.h, -1, 1)
	self.empty_view = vmath.matrix4()
	FEATURES:on_resize(self.screen_size.w, self.screen_size.h)
	GUI_RESIZER.update_screen_size(self.screen_size, self.config_size)
end

function Render:calculate_screen_size()
	self.screen_size.w = render.get_window_width()
	self.screen_size.h = render.get_window_height()
	if (self.screen_size.w == 0) then self.screen_size.w = 1 end
	if (self.screen_size.h == 0) then self.screen_size.h = 1 end
	self.screen_size.aspect = self.screen_size.w / self.screen_size.h
	---@diagnostic disable-next-line: inject-field
	self.draw_opts.constants.screen_size_game = vmath.vector4(self.screen_size.w, self.screen_size.h, self.screen_size.aspect, 0)
end

function Render:on_message(message_id)
	if message_id == HASH_WINDOW_RESIZED then
		local prev_w = self.screen_size.w
		local prev_h = self.screen_size.h
		self:calculate_screen_size()

		if (prev_w ~= self.screen_size.w or prev_h ~= self.screen_size.h) then
			LOG.i("screen size changed. from " .. "w:" .. prev_w .. " h:" .. prev_h
				.. " to w:" .. self.screen_size.w .. " h:" .. self.screen_size.h, TAG)
			self:window_size_changed()
			EVENTS.WINDOW_RESIZED:trigger(self.screen_size.w, self.screen_size.h)
		end
	end
end

function Render:update(_)
	self.constants.time.x = GAME.state.time
	---@diagnostic disable-next-line: inject-field
	self.draw_opts.constants.time = self.constants.time

	---#region constants for model player clip
	if GAME.level_creator.player then
		-- Obtain the view matrix
		CAMERAS.current_camera:get_view_to_matrix(TEMP_MATRIX4)

		local player_pos = GAME.level_creator.player.position
		-- Set the components of the player's world position into TEMP_V
		xmath.vector4_set_components(TEMP_V, player_pos.x, player_pos.y + 1.5, player_pos.z, 1)

		-- Transform the player's position from world space to view space
		xmath.matrix_mul_v4(TEMP_V, TEMP_MATRIX4, TEMP_V)
		xmath.vector4_set_components(self.constants.player_pos_view, TEMP_V.x, TEMP_V.y, TEMP_V.z, TEMP_V.w)
		---@diagnostic disable-next-line: inject-field
		self.draw_opts.constants.player_pos_view = self.constants.player_pos_view
		local player_view_pos = vmath.vector4(self.constants.player_pos_view)

		-- Obtain the projection matrix
		CAMERAS.current_camera:get_proj_to_matrix(TEMP_MATRIX4);
		-- Transform the player's position from view space to clip space
		xmath.matrix_mul_v4(TEMP_V, TEMP_MATRIX4, TEMP_V)
		local clip_w = TEMP_V.w ~= 0 and TEMP_V.w or 1
		local inv_w = 1 / clip_w
		local ndc_x = TEMP_V.x * inv_w
		local ndc_y = TEMP_V.y * inv_w
		local ndc_z = TEMP_V.z * inv_w
		xmath.vector4_set_components(self.constants.player_pos_clip, ndc_x, ndc_y, ndc_z, 1)
		-- Calculate clip radius in screen space based on projected player size
		local player_radius_world = 0.6
		local padding = 1.0

		local offset_view_x = vmath.vector4(player_view_pos)
		offset_view_x.x = offset_view_x.x + player_radius_world
		xmath.matrix_mul_v4(offset_view_x, TEMP_MATRIX4, offset_view_x)
		local offset_x_w = offset_view_x.w ~= 0 and offset_view_x.w or 1
		local offset_ndc_x = offset_view_x.x / offset_x_w
		local radius_ndc_x = math.abs((offset_ndc_x - ndc_x) * self.screen_size.aspect)

		local offset_view_y = vmath.vector4(player_view_pos)
		offset_view_y.y = offset_view_y.y + player_radius_world
		xmath.matrix_mul_v4(offset_view_y, TEMP_MATRIX4, offset_view_y)
		local offset_y_w = offset_view_y.w ~= 0 and offset_view_y.w or 1
		local offset_ndc_y = offset_view_y.y / offset_y_w
		local radius_ndc_y = math.abs(offset_ndc_y - ndc_y)

		local clip_radius = math.max(radius_ndc_x, radius_ndc_y) * padding
		self.constants.clip.x = math.max(clip_radius * 0.95 + 0.01, 0)
		self.constants.clip.y = 0.18
		self.constants.clip.z = 0
		---@diagnostic disable-next-line: inject-field
		self.draw_opts.constants.clip = self.constants.clip
	else
		xmath.vector4_set_components(self.constants.player_pos_clip, 0, 0, -1, 1)
		xmath.vector4_set_components(self.constants.player_pos_view, 0, 0, 0, 1)
		---@diagnostic disable-next-line: inject-field
		self.draw_opts.constants.player_pos_view = self.constants.player_pos_view
		self.constants.clip.x = 0
		self.constants.clip.y = 0
		self.constants.clip.z = 0
		---@diagnostic disable-next-line: inject-field
		self.draw_opts.constants.clip = self.constants.clip
	end
	---#endregion

	GAME.lights:set_enable_shadows(IlluminationFeature.storage:draw_shadows_get())

	CAMERAS.current_camera:get_view_to_matrix(self.view)
	CAMERAS.current_camera:get_proj_to_matrix(self.proj)
	CAMERAS.current_camera:get_frustum_to_matrix(self.frustum)

	local shadowFrustum = vmath.matrix4()
	local farZ = CAMERAS.current_camera:get_far_z()
	--CAMERAS.current_camera:set_far_z(45)
	if GAME.level_creator.player then
		CAMERAS.current_camera:set_far_z(40 + GAME.level_creator.player.camera.distance.value)
	else
		CAMERAS.current_camera:set_far_z(45)
	end
	CAMERAS.current_camera:get_frustum_to_matrix(shadowFrustum)
	CAMERAS.current_camera:set_far_z(farZ)

	GAME.lights:set_view(self.view)
	GAME.lights:set_frustum(shadowFrustum)

	GAME.lights:set_lights_camera_aspect(self.screen_size.aspect)
	GAME.lights:set_lights_camera_fov(CAMERAS.current_camera:get_fov())
	GAME.lights:set_lights_camera_far(CAMERAS.current_camera:get_far_z())
	GAME.lights:set_lights_camera_near(CAMERAS.current_camera:get_near_z())

	local player = GAME.level_creator.player
	if player then
		GAME.lights:set_camera(player.position.x, player.position.y, player.position.z)
	end

	GAME.lights:set_frustum(self.frustum)
	GAME.lights:update_lights()

	GAME.lights:set_frustum(shadowFrustum)
	GAME.lights:render_shadows()

	render.set_viewport(0, 0, self.screen_size.w, self.screen_size.h)
	render.set_view(self.view)
	render.set_projection(self.proj)
	render.set_depth_mask(false)
	render.set_stencil_mask(0xff)
	render.clear(self.clear)

	render.enable_state(graphics.STATE_DEPTH_TEST)
	render.enable_state(graphics.STATE_CULL_FACE)
	render.disable_state(graphics.STATE_STENCIL_TEST)
	render.disable_state(graphics.STATE_BLEND)
	render.set_blend_func(graphics.BLEND_FACTOR_ONE, graphics.BLEND_FACTOR_ONE_MINUS_SRC_ALPHA)

	--render.disable_state(graphics.STATE_CULL_FACE)
	render.draw(self.predicates.char, self.draw_opts)
	--render.enable_state(graphics.STATE_CULL_FACE)
	render.draw(self.predicates.tile, self.draw_opts)
	render.draw(self.predicates.model_no_shadow, self.draw_opts)

	GAME.lights:draw_begin()
	render.draw(self.predicates.model, self.draw_opts)
	GAME.lights:draw_finish()

	render.enable_state(graphics.STATE_BLEND)
	render.disable_state(graphics.STATE_CULL_FACE)
	render.draw(self.predicates.arrow, self.draw_opts)
	render.set_depth_mask(false)
	render.draw(self.predicates.particles_world, self.draw_opts)
	render.set_depth_mask(true)
	--render.set_depth_mask(false)
	render.disable_state(graphics.STATE_DEPTH_TEST)
	render.draw(self.predicates.gui_world, self.draw_opts)
	render.draw(self.predicates.gui_world_font, self.draw_opts)
	render.set_depth_mask(false)
	render.enable_state(graphics.STATE_DEPTH_TEST)
	render.draw(self.predicates.rect_area, self.draw_opts)
	--render.draw(self.predicates.model_area_glow, self.draw_opts)
	render.draw(self.predicates.model_transparent, self.draw_opts)
	render.draw(self.predicates.sprite_3d, self.draw_opts)
	render.draw(self.predicates.sprite_glow, self.draw_opts)

	render.draw_debug3d()


	-- GUI Rendering
	render.set_depth_mask(false)
	render.disable_state(graphics.STATE_DEPTH_TEST)
	render.enable_state(graphics.STATE_BLEND)
	render.disable_state(graphics.STATE_CULL_FACE)

	render.enable_state(graphics.STATE_STENCIL_TEST)
	render.set_view(self.empty_view)
	render.set_projection(self.gui_proj)
	render.draw(self.predicates.gui)
	render.disable_state(graphics.STATE_STENCIL_TEST)

	if IlluminationFeature.storage:is_debug_shadow() then
		GAME.lights:draw_shadow_debug()
	end

	if IlluminationFeature.storage:is_debug_lights() then
		GAME.lights:draw_data_lights_debug()
		GAME.lights:draw_debug_planes()
	end
end

N28S.register(Render)
