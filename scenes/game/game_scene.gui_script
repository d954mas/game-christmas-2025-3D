local CLASS = require "libs.class"
local CONTEXTS = require "libs.contexts_manager"
local SM = require "libs.sm.scene_manager"
local CONSTANTS = require "libs.constants"
local GAME = require "game.game_world"
local BaseGuiScript = require "project.base_gui_script"
local N28S = require "libs.n28s"
local ButtonScale = require "libs.gui.button_scale"
local VirtualPad = require "libs.gui.virtual_pad"
local ACTIONS = require "libs.actions.actions"
local TWEEN = require "libs.tween"
local STORAGE = require "libs.storage.storage"
local OfferView = require "libs.gui.offer_view"
local LUME = require "libs.lume"
local DEFS = require "game.balance.defs.defs"
local GUI_UTILS = require "libs.gui.gui_utils"
local SOUNDS = require "libs.sounds"
local HASH = require "libs.hashes"
local EVENTS = require "libs.events"
local ENUMS = require "game.balance.defs.enums"
local LOCALIZATION = require "libs.localization"
local AutosizeLbl = require "libs.gui.autosize_label"
local ProgressBar = require "libs.gui.progress_bar"
local GuiResizer = require "libs.gui_resizer"
local OreListView = require "scenes.game.ore_list_view"
local ResourceListView = require "scenes.game.resource_list_view"
local ModeToggleView = require "libs.gui.mode_toggle_view"
local BuildableCosts = require "game.buildable_costs"

local MATERIAL_GUI_DARKER = hash("gui_darker")

local SCALE_1 = vmath.vector3(1)
local SCALE_COMPLETED = vmath.vector3(1.3)
local SCALE_HIDE = vmath.vector3(0.01)

local TEMP_Q = vmath.quat_rotation_z(0)

local Notification = CLASS.class("Notification")

function Notification.new() return CLASS.new_instance(Notification) end

function Notification:initialize()
	local nodes = gui.clone_tree(gui.get_node("notification_drill_unlocked/root"))
	self.vh = {
		root = nodes[hash("notification_drill_unlocked/root")],
		bg = nodes[hash("notification_drill_unlocked/bg")],
		rays = nodes[hash("notification_drill_unlocked/rays")],
		icon = nodes[hash("notification_drill_unlocked/icon")],
		title = AutosizeLbl.new(nodes[hash("notification_drill_unlocked/title")]),
		lbl = AutosizeLbl.new(nodes[hash("notification_drill_unlocked/lbl")]),
	}
	self.vh.title:set_text(LOCALIZATION:translate("unlocked"))
	self.angle = 0
	self.action = ACTIONS.Sequence.new()
	self.action.drop_empty = false
	gui.set_color(self.vh.root, vmath.vector4(1, 1, 1, 0))
	gui.set_scale(self.vh.root, vmath.vector3(0.001))
end

function Notification:update(dt)
	if self.vh then
		self.angle = self.angle - dt * math.pi * 0.1
		xmath.quat_rotation_z(TEMP_Q, self.angle)
		gui.set_rotation(self.vh.rays, TEMP_Q)
		self.action:update(dt)
	end
end

function Notification:animate()
	gui.set_enabled(self.vh.root, true)
	local show = ACTIONS.Parallel.new(false)

	show:add_action(ACTIONS.TweenGui.new_noctx({
		object = self.vh.root, property = "color",
		from = vmath.vector4(1, 1, 1, 0), to = vmath.vector4(1, 1, 1, 1), time = 0.6,
		easing = TWEEN.easing.inQuad
	}))
	show:add_action(ACTIONS.TweenGui.new_noctx({
		object = self.vh.root, property = "scale",
		from = vmath.vector3(0.001), to = vmath.vector3(1), time = 1,
		easing = TWEEN.easing.inOutBounce
	}))

	self.action:add_action(show)
	self.action:add_action(ACTIONS.Wait.new(1.5))
	self.action:add_action(ACTIONS.TweenGui.new_noctx({
		object = self.vh.root, property = "color",
		from = vmath.vector4(1), to = vmath.vector4(1, 1, 1, 0), time = 0.5,
		easing = TWEEN.easing.outQuad
	}))
	self.action:add_action(function ()
		gui.delete_node(self.vh.root)
		self.vh = nil
	end, false)
	self:on_resize()
end

function Notification:on_resize()
	gui.set_adjust_mode(self.vh.root, GuiResizer.get_mode())
	gui.set_scale(self.vh.root, GuiResizer.get_scale(3).scale)
end

function Notification:set_text(text)
	self.vh.lbl:set_text(text)
end

function Notification:set_icon(icon)
	gui.play_flipbook(self.vh.icon, icon)
end

local NotificationOre = CLASS.class("NotificationOre")

function NotificationOre.new() return CLASS.new_instance(NotificationOre) end

function NotificationOre:initialize()
	local nodes = gui.clone_tree(gui.get_node("notification_ore_unlocked/root"))
	self.vh = {
		root = nodes[hash("notification_ore_unlocked/root")],
		bg = nodes[hash("notification_ore_unlocked/bg")],
		rays = nodes[hash("notification_ore_unlocked/rays")],
		title = AutosizeLbl.new(nodes[hash("notification_ore_unlocked/title")]),
		lbl = AutosizeLbl.new(nodes[hash("notification_ore_unlocked/lbl")]),
	}
	self.angle = 0
	self.action = ACTIONS.Sequence.new()
	self.action.drop_empty = false
	gui.set_color(self.vh.root, vmath.vector4(1, 1, 1, 0))
	gui.set_scale(self.vh.root, vmath.vector3(0.001))
	self.notification_wait = 1
	self.vh.title:set_text(LOCALIZATION:translate("new_ore"))
end

function NotificationOre:update(dt)
	if self.vh then
		self.angle = self.angle - dt * math.pi * 0.1
		xmath.quat_rotation_z(TEMP_Q, self.angle)
		gui.set_rotation(self.vh.rays, TEMP_Q)
		self.action:update(dt)
	end
end

function NotificationOre:animate()
	gui.set_enabled(self.vh.root, true)
	local show = ACTIONS.Parallel.new(false)

	show:add_action(ACTIONS.TweenGui.new_noctx({
		object = self.vh.root, property = "color",
		from = vmath.vector4(1, 1, 1, 0), to = vmath.vector4(1, 1, 1, 1), time = 0.6,
		easing = TWEEN.easing.inQuad
	}))
	show:add_action(ACTIONS.TweenGui.new_noctx({
		object = self.vh.root, property = "scale",
		from = vmath.vector3(0.001), to = vmath.vector3(1), time = self.notification_wait,
		easing = TWEEN.easing.inOutBounce
	}))

	self.action:add_action(show)
	self.action:add_action(ACTIONS.Wait.new(self.notification_wait))
	self.action:add_action(ACTIONS.TweenGui.new_noctx({
		object = self.vh.root, property = "color",
		from = vmath.vector4(1), to = vmath.vector4(1, 1, 1, 0), time = 0.5,
		easing = TWEEN.easing.outQuad
	}))
	self.action:add_action(function ()
		gui.delete_node(self.vh.root)
		self.vh = nil
	end, false)
	self:on_resize()
end

function NotificationOre:on_resize()
	gui.set_adjust_mode(self.vh.root, GuiResizer.get_mode())
	gui.set_scale(self.vh.root, GuiResizer.get_scale(3).scale)
end

function NotificationOre:set_ore(id)
	local ore = assert(DEFS.ORE.BY_ID[id])
	self.vh.lbl:set_text(LOCALIZATION:translate(ore.title))
	local quality = DEFS.ORE.QUALITY_LIST[ore.quality]
	gui.set_scale(self.vh.lbl.node, vmath.vector3(quality.size * 1.5))
	self:set_text_color(quality.color)
	self.notification_wait = quality.notification_wait
end

function NotificationOre:set_text_color(color)
	gui.set_color(self.vh.lbl.node, color)
end

local TaskView = CLASS.class("TaskView")
local XP_REWARD_ICON = hash("icon_upgrades")
local BTN_UPGRADE_BORDER_COLOR = vmath.vector4(0.4, 0.502, 0.902, 1)
local BTN_UPGRADE_BG_COLOR = vmath.vector4(0.102, 0.2, 0.6, 1)
local BTN_UPGRADE_BORDER_DISABLED_COLOR = vmath.vector4(0.2, 0.2, 0.2, 1)
local BTN_UPGRADE_BG_DISABLED_COLOR = vmath.vector4(0.12, 0.12, 0.12, 1)

function TaskView.new() return CLASS.new_instance(TaskView) end

function TaskView:initialize()
	local vh_progress = {
		root = gui.get_node("task/current/progress/root"),
		bg = gui.get_node("task/current/progress/bg"),
		progress = gui.get_node("task/current/progress/progress"),
		lbl = gui.get_node("task/current/progress/lbl")
	}

	self.vh = {
		root = gui.get_node("task/root"),
		icon = gui.get_node("task/icon"),
		current = {
			root = gui.get_node("task/current"),
			lbl = AutosizeLbl.new("task/lbl_description"),
		},
		reward = {
			root = gui.get_node("task/reward/root"),
			icon = gui.get_node("task/reward/icon"),
			lbl = gui.get_node("task/reward/value")
		},
		---@class ProgressBarTask:ProgressBar
		---@field task_def table
		---@diagnostic disable-next-line: assign-type-mismatch
		progress = ProgressBar.new(vh_progress)
	}
	self.actions = ACTIONS.Sequence.new(false)
	self.actions.drop_empty = false


	---@param progress ProgressBarTask
	self.vh.progress.lbl_format_value = function (progress)
		if progress.task_def.type == DEFS.TASKS.TYPE.BUILD_ISLAND_PERCENT then
			local format_value = math.floor(progress.animation.value * 10000) / 100 + progress.task_def.value_start * 100
			local format_max = math.floor(progress.value_max * 10000) / 100 + progress.task_def.value_start * 100
			return string.format("%.1f/%.1f%%", format_value, format_max)
		else
			local f = progress.animation.value > progress.value_max / 2 and math.ceil or math.floor
			return (LUME.formatIdleNumber(f(progress.animation.value)) .. "/" .. LUME.formatIdleNumber(progress.value_max))
		end
	end
end

function TaskView:set_id(id)
	self.def = DEFS.TASKS.TASKS_BY_ID[id]
	gui.play_flipbook(self.vh.icon, self.def.icon)
	local reward = self.def.rewards[1]
	local reward_value = reward.value
	if reward.exp then
		gui.play_flipbook(self.vh.reward.icon, XP_REWARD_ICON)
	elseif reward.resource then
		gui.play_flipbook(self.vh.reward.icon, DEFS.RESOURCES.BY_ID[reward.resource].icon)
	else
		gui.play_flipbook(self.vh.reward.icon, XP_REWARD_ICON)
	end
	gui.set_text(self.vh.reward.lbl, "+" .. LUME.formatIdleNumber(reward_value))
	gui.set_enabled(self.vh.root, self.def.type ~= DEFS.TASKS.TYPE.ALL_COMPLETED)
	GUI_UTILS.set_nodes_to_center(self.vh.reward.lbl, self.vh.reward.icon, 3)
	self.vh.progress.task_def = self.def
	if self.def.value_start then
		self.vh.progress:set_value_max(self.def.value - self.def.value_start)
	else
		self.vh.progress:set_value_max(self.def.value)
	end
	self.vh.progress:set_value(0, true)
	self.vh.progress:update(1)
	self.vh.progress:update(1)
end

function TaskView:on_storage_changed()
	if STORAGE.task:can_complete() then
		if self.actions:is_empty() then
			SOUNDS:play_sound(SOUNDS.sounds.task_done, { play_properties = { delay = 0.1 } })
			self.actions:add_action(ACTIONS.TweenGui.new_noctx({
				object = self.vh.root, property = "scale",
				from = SCALE_1, to = SCALE_COMPLETED, time = 0.6, easing = TWEEN.easing.outBack, delay = 0.0
			}), false)
			self.actions:add_action(ACTIONS.TweenGui.new_noctx({
				object = self.vh.root, property = "scale",
				from = SCALE_COMPLETED, to = SCALE_HIDE, time = 0.5, easing = TWEEN.easing.inQuad, delay = 0.0
			}), false)
			self.actions:add_action(function ()
				STORAGE.task:complete()
				self:set_id(STORAGE.task:get_id())
				self:on_storage_changed()
			end, false)
			self.actions:add_action(ACTIONS.TweenGui.new_noctx({
				object = self.vh.root, property = "scale",
				from = SCALE_HIDE, to = SCALE_1, time = 0.5, easing = TWEEN.easing.inQuad, delay = 0.0
			}), false)
			self.actions:add_action(function ()
				timer.delay(0.05, false, function ()
					STORAGE.task:check_current_task(GAME.level_creator.location_data) --check next task is completed
				end)
			end, true)
		end
	end

	local value = STORAGE.task:get_value()

	local params = {}
	if self.def.type == DEFS.TASKS.TYPE.COLLECT_RESOURCE and self.def.resource then
		local res_def = DEFS.RESOURCES.BY_ID[self.def.resource]
		local resource_name = LOCALIZATION:translate("res_" .. res_def.id)
		params.value = string.format("%d %s", self.def.value or 0, resource_name)
	elseif self.def.type == DEFS.TASKS.TYPE.UPGRADE and self.def.upgrade then
		local upgrade_def = DEFS.UPGRADES.BY_ID[self.def.upgrade]
		if upgrade_def then
			params.value = LOCALIZATION:translate(upgrade_def.title)
		end
	elseif self.def.type == DEFS.TASKS.TYPE.BUILD and self.def.buildable then
		local buildable_def = DEFS.BUILDABLES.BY_ID[self.def.buildable]
		if buildable_def then
			params.value = LOCALIZATION:translate(buildable_def.title)
		end
	end
	if not params.value then
		params.value = tostring(self.def.value or "")
	end
	local task_locale = "task_type_" .. self.def.type
	if self.def.title then
		task_locale = self.def.title
	end
	local text = LOCALIZATION:translate(task_locale, params)
	self.vh.current.lbl:set_text(text)
	self.vh.progress:set_value(value)
end

function TaskView:update(dt)
	self.actions:update(dt)
	self.vh.progress:update(dt)
end

local PowerPickaxeGoldView = CLASS.class("PowerPickaxeGoldView")

function PowerPickaxeGoldView.new()
	return CLASS.new_instance(PowerPickaxeGoldView)
end

function PowerPickaxeGoldView:initialize()
	self.vh = {
		root = gui.get_node("powerup_view_pickaxe_gold/root"),
		timer_lbl = gui.get_node("powerup_view_pickaxe_gold/timer/lbl"),
	}
end

function PowerPickaxeGoldView:update()
	local active = STORAGE.power_ups:get_state(DEFS.POWERUPS.PICKAXE_GOLD.id) == ENUMS.POWERUP_STATE.ACTIVE
	gui.set_enabled(self.vh.root, active)
	if active then
		gui.set_text(self.vh.timer_lbl, LUME.get_human_time(STORAGE.power_ups:get_active_countdown(DEFS.POWERUPS.PICKAXE_GOLD.id)))
	end
end

local BUILD_SELECTED_COST_GROUPS = 5
local BUILD_SELECTED_ICON_LABEL_GAP = 4
local BUILD_SELECTED_PAIR_GAP = 8
local BUILD_SELECTED_LINE_PADDING = 20
local BUILD_SELECTED_TEXT_METRICS = { tracking = 0, line_break = false, width = 0 }

local function build_selected_measure_width(node, text)
	BUILD_SELECTED_TEXT_METRICS.tracking = gui.get_tracking(node)
	BUILD_SELECTED_TEXT_METRICS.line_break = gui.get_line_break(node)
	BUILD_SELECTED_TEXT_METRICS.width = gui.get_size(node).x
	local font = gui.get_font(node)
	local metrics = resource.get_text_metrics(gui.get_font_resource(font), text, BUILD_SELECTED_TEXT_METRICS)
	local scale = gui.get_scale(node)
	return metrics.width * scale.x
end

local function build_selected_node_width(node)
	local size = gui.get_size(node)
	local scale = gui.get_scale(node)
	return size.x * scale.x
end

local SelectedBuildInfoView = CLASS.class("SelectedBuildInfoView")

function SelectedBuildInfoView.new()
	return CLASS.new_instance(SelectedBuildInfoView)
end

function SelectedBuildInfoView:initialize()
	self.vh = {
		root = gui.get_node("build_selected/root"),
		bg = gui.get_node("build_selected/bg"),
		icon = gui.get_node("build_selected/icon"),
		cost_root = gui.get_node("build_selected/cost"),
		title = AutosizeLbl.new(gui.get_node("build_selected/title")),
	}
	self.colors = {
		bg_enabled = vmath.vector4(1, 1, 1, 0.95),
		bg_disabled = vmath.vector4(0.55, 0.35, 0.35, 0.95),
		title_enabled = vmath.vector4(1, 1, 1, 1),
		title_disabled = vmath.vector4(0.9, 0.65, 0.65, 1),
		cost_disabled = vmath.vector4(0.9, 0.65, 0.65, 1),
		icon_disabled = vmath.vector4(0.8, 0.6, 0.6, 1),
	}
	self.current_id = nil
	self.current_def = nil
	self.cost_entries_source = nil
	self.can_spend = nil
	self.cost_groups = {}
	self.cost_label_y = 0
	self.cost_icon_y = 0
	self.cost_center_x = 0
	for i = 1, BUILD_SELECTED_COST_GROUPS do
		local icon = gui.get_node(string.format("build_selected/cost/icon_%d", i))
		local label_node = gui.get_node(string.format("build_selected/cost/value_%d", i))
		local label = AutosizeLbl.new(label_node)
		self.cost_groups[i] = {
			icon = icon,
			icon_base_scale = gui.get_scale(icon),
			label = label,
			resource_color = CONSTANTS.COLORS.WHITE,
		}
		local label_pos = gui.get_position(label_node)
		local icon_pos = gui.get_position(icon)
		self.cost_label_y = self.cost_label_y + label_pos.y
		self.cost_icon_y = self.cost_icon_y + icon_pos.y
		gui.set_enabled(icon, false)
		label:set_enabled(false)
	end
	if BUILD_SELECTED_COST_GROUPS > 0 then
		self.cost_label_y = self.cost_label_y / BUILD_SELECTED_COST_GROUPS
		self.cost_icon_y = self.cost_icon_y / BUILD_SELECTED_COST_GROUPS
	end
	gui.set_enabled(self.vh.root, false)
end

function SelectedBuildInfoView:hide()
	if gui.is_enabled(self.vh.root) then
		gui.set_enabled(self.vh.root, false)
	end
	self.current_def = nil
	self.current_id = nil
	self.cost_entries_source = nil
	self.can_spend = nil
	for _, group in ipairs(self.cost_groups) do
		gui.set_enabled(group.icon, false)
		group.label:set_text("")
		group.label:set_enabled(false)
		group.resource_color = CONSTANTS.COLORS.WHITE
	end
end

function SelectedBuildInfoView:apply_def(def)
	self.current_def = def
	self.current_id = def.id
	if def.icon then
		gui.play_flipbook(self.vh.icon, def.icon)
	end
	self.vh.title:set_text(LOCALIZATION:translate(def.title))
	self:set_cost_entries(def.cost)
end

function SelectedBuildInfoView:get_cost_available_width()
	local node = self.vh.cost_root or self.vh.bg
	local size = gui.get_size(node)
	local scale = gui.get_scale(node)
	local width = size.x * scale.x
	if width <= 0 and node ~= self.vh.bg then
		size = gui.get_size(self.vh.bg)
		scale = gui.get_scale(self.vh.bg)
		width = size.x * scale.x
	end
	return math.max(width - BUILD_SELECTED_LINE_PADDING, 0)
end

function SelectedBuildInfoView:set_cost_entries(cost_entries)
	self.cost_entries_source = cost_entries or {}
	local display_entries = BuildableCosts.get_display_entries(self.cost_entries_source, #self.cost_groups)
	local active_count = #display_entries
	local entries_data = {}
	local total_width = 0
	for i = 1, active_count do
		local group = self.cost_groups[i]
		local entry = display_entries[i]
		local resource_def = BuildableCosts.get_resource_def(entry.resource)
		local icon_name = resource_def and resource_def.icon or "icon_gold_border"
		group.resource_color = resource_def and resource_def.font_color or CONSTANTS.COLORS.WHITE
		gui.play_flipbook(group.icon, hash(icon_name))
		local text = LUME.formatIdleNumber(entry.value)
		group.label:set_text(text)
		group.label:set_enabled(true)
		gui.set_enabled(group.icon, true)
		local label_node = group.label.node
		local text_width = build_selected_measure_width(label_node, text)
		local icon_width = build_selected_node_width(group.icon)
		if icon_width == 0 then icon_width = 8 end
		local pair_width = text_width + BUILD_SELECTED_ICON_LABEL_GAP + icon_width
		total_width = total_width + pair_width
		if i < active_count then
			total_width = total_width + BUILD_SELECTED_PAIR_GAP
		end
		entries_data[i] = {
			label_node = label_node,
			label_scale = gui.get_scale(label_node),
			text_width = text_width,
			icon_width = icon_width,
		}
	end

	local available_width = self:get_cost_available_width()
	local scale = 1
	if total_width > available_width and total_width > 0 then
		scale = available_width / total_width
	end
	local total_scaled_width = total_width * scale
	local cursor = -total_scaled_width * 0.5
	local center_x = self.cost_center_x or 0

	for i = 1, #self.cost_groups do
		local group = self.cost_groups[i]
		local data = entries_data[i]
		if data then
			gui.set_enabled(group.icon, true)
			gui.set_scale(group.icon, group.icon_base_scale * scale)
			group.label:set_enabled(true)
			gui.set_scale(data.label_node, data.label_scale * scale)

			local label_pos = vmath.vector3(center_x + cursor, self.cost_label_y, 0)
			gui.set_position(data.label_node, label_pos)

			local label_width = data.text_width * scale
			cursor = cursor + label_width + BUILD_SELECTED_ICON_LABEL_GAP * scale

			local icon_width = data.icon_width * scale
			local icon_pos = vmath.vector3(center_x + cursor + icon_width * 0.5, self.cost_icon_y, 0)
			gui.set_position(group.icon, icon_pos)
			cursor = cursor + icon_width

			if i < active_count then
				cursor = cursor + BUILD_SELECTED_PAIR_GAP * scale
			end
		else
			gui.set_enabled(group.icon, false)
			group.label:set_text("")
			group.label:set_enabled(false)
			group.resource_color = CONSTANTS.COLORS.WHITE
		end
	end
	self.can_spend = nil
end

function SelectedBuildInfoView:update_affordable()
	local can_spend = BuildableCosts.can_afford(STORAGE.resources, self.cost_entries_source)
	if self.can_spend == can_spend then return end
	self.can_spend = can_spend
	local bg_color = can_spend and self.colors.bg_enabled or self.colors.bg_disabled
	gui.set_color(self.vh.bg, bg_color)
	local title_color = can_spend and self.colors.title_enabled or self.colors.title_disabled
	gui.set_color(self.vh.title.node, title_color)
	local icon_color = can_spend and CONSTANTS.COLORS.WHITE or self.colors.icon_disabled
	gui.set_color(self.vh.icon, icon_color)
	for _, group in ipairs(self.cost_groups) do
		local label_color = can_spend and group.resource_color or self.colors.cost_disabled
		gui.set_color(group.label.node, label_color)
		gui.set_color(group.icon, icon_color)
	end
end

function SelectedBuildInfoView:update()
	local build_mode = GAME.state.build_mode
	local build_item = build_mode.build_item
	local id = (build_mode.enable and build_item and build_item.id) or nil
	if not id then
		self:hide()
		return
	end
	local def = DEFS.BUILDABLES.BY_ID[id]
	if not def then
		self:hide()
		return
	end
	if self.current_id ~= id then
		self:apply_def(def)
	end
	if not gui.is_enabled(self.vh.root) then
		gui.set_enabled(self.vh.root, true)
	end
	self:update_affordable()
end

function SelectedBuildInfoView:on_language_changed()
	if not self.current_def then return end
	self.vh.title:set_text(LOCALIZATION:translate(self.current_def.title))
	self:set_cost_entries(self.current_def.cost)
	self:update_affordable()
end

---@class GameSceneGuiScript:BaseGuiScript
local Script = CLASS.class("GameSceneGuiScript", BaseGuiScript)

function Script:init()
	BaseGuiScript.init(self, { context_name = CONTEXTS.NAMES.GAME_GUI, scene = SM:get_scene_by_name(SM.SCENES.GAME) })
end

function Script:bind_vh()
	self.vh = {
		top_left = gui.get_node("top_left"),
		top = gui.get_node("top"),
		top_right = gui.get_node("top_right"),
		left = gui.get_node("left"),
		right = gui.get_node("right"),
		bottom_left = gui.get_node("bottom_left"),
		bottom = gui.get_node("bottom"),
		bottom_right = gui.get_node("bottom_right"),
		offer = gui.get_node("offer/root"),
		tooltip = {
			pc = {
				root = gui.get_node("tooltip_pc"),
				keys = {
					root = gui.get_node("tooltip_pc/keys"),

				},
			},
			mobile = {
				root = gui.get_node("tooltip_mobile"),
				pointer_pad = gui.get_node("virtual_pad/tooltip_pointer"),
			}
		},
		btn_rebirth_glow = gui.get_node("btn_rebirth/glow"),
		btn_upgrade_bg = gui.get_node("btn_upgrade/bg"),
		btn_upgrade_border = gui.get_node("btn_upgrade/bg_borders"),
		pointers = {
			btn_upgrade = gui.get_node("btn_upgrade/tooltip_pointer"),
			btn_islands = gui.get_node("btn_islands/tooltip_pointer"),
			btn_mode = gui.get_node("btn_mode/tooltip_pointer"),
			btn_build = gui.get_node("btn_build/tooltip_pointer"),
		}
	}

	self.pc_input_tooltips = {
		gui.get_node("btn_build/input_tooltip/root"),
		gui.get_node("btn_remove/input_tooltip/root"),
	}

	local progress_vh = {
		root = gui.get_node("btn_upgrade/progress/root"),
		bg = gui.get_node("btn_upgrade/progress/bg"),
		progress = gui.get_node("btn_upgrade/progress/progress"),
	}

	self.views = {
		btn_settings = ButtonScale.new("btn_settings"),
		btn_upgrade = ButtonScale.new("btn_upgrade"),
		btn_upgrade_progress = ProgressBar.new(progress_vh),
		btn_upgrade_progress_label = gui.get_node("btn_upgrade/progress/label"),
		btn_upgrade_lbl = AutosizeLbl.new("btn_upgrade/lbl"),
		btn_islands = ButtonScale.new("btn_islands"),
		btn_zoom_plus = ButtonScale.new("btn_zoom_plus"),
		btn_zoom_minus = ButtonScale.new("btn_zoom_minus"),
		btn_build = ButtonScale.new("btn_build"),
		btn_remove = ButtonScale.new("btn_remove"),
		btn_rebirth = ButtonScale.new("btn_rebirth"),
		btn_rebirth_lbl = AutosizeLbl.new("btn_rebirth/lbl"),
		btn_pets = ButtonScale.new("btn_pets"),
		btn_pets_lbl = AutosizeLbl.new("btn_pets/lbl"),
		btn_islands_lbl = AutosizeLbl.new("btn_islands/lbl"),
		btn_ore = ButtonScale.new("btn_ore"),
		btn_ore_lbl = AutosizeLbl.new("btn_ore/lbl"),
		virtual_pad = VirtualPad.new("virtual_pad"),
		task = TaskView.new(),
		powerup_pickaxe_gold_view = PowerPickaxeGoldView.new(),
		ore_list = OreListView.new("resources"),
		resource_list = ResourceListView.new("resource_list"),
		btn_remove_lbl = AutosizeLbl.new("btn_remove/lbl"),
		btn_build_lbl = AutosizeLbl.new("btn_build/lbl"),
		build_selected_info = SelectedBuildInfoView.new(),
	}

	self.views.mode_toggle = ModeToggleView.new()

	self.notifications = {}
	self.notifications_ore = {}

	local progress_vh = {
		root = gui.get_node("btn_rebirth/progress/root"),
		bg = gui.get_node("btn_rebirth/progress/bg"),
		progress = gui.get_node("btn_rebirth/progress/progress"),
	}

	gui.animate(self.vh.btn_rebirth_glow, "euler.z", -360, gui.EASING_LINEAR, 10, 0, nil, gui.PLAYBACK_LOOP_FORWARD)
	gui.animate(self.vh.btn_rebirth_glow, "scale", vmath.vector3(0.96), gui.EASING_INBACK, 4, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)

	self.views.btn_rebirth_progress = ProgressBar.new(progress_vh)
end

function Script:show_tooltip_input()
	local is_mobile = CONSTANTS.IS_MOBILE_DEVICE
	local tooltip_vh = self.vh.tooltip
	gui.set_enabled(tooltip_vh.pc.root, not is_mobile)
	gui.set_enabled(tooltip_vh.mobile.root, is_mobile)
	--gui.set_enabled(tooltip_vh.mobile.pointer_pad, is_mobile)

	if not is_mobile then
		gui.animate(tooltip_vh.pc.keys.root, "scale", 1.1, gui.EASING_OUTQUAD, 2, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
	end
	gui.set_color(self.vh.tooltip.mobile.pointer_pad, CONSTANTS.COLORS.EMPTY)
	local position_start = vmath.vector3(0, 0, 0)
	local position_end = vmath.vector3(72, 72, 0)
	local create_sequence
	create_sequence = function ()
		if not gui.is_enabled(self.vh.tooltip.mobile.pointer_pad) then return end
		local pad_actions = ACTIONS.Sequence.new(false)

		gui.set_position(self.vh.tooltip.mobile.pointer_pad, position_start)

		pad_actions:add_action(ACTIONS.TweenGui.new_noctx({
			object = self.vh.tooltip.mobile.pointer_pad, property = "color",
			to = CONSTANTS.COLORS.WHITE, time = 0.15, easing = TWEEN.easing.outCubic
		}))

		pad_actions:add_action(ACTIONS.TweenGui.new_noctx({
			object = self.vh.tooltip.mobile.pointer_pad, property = "position",
			from = position_start, to = position_end, time = 2, easing = TWEEN.easing.outCubic, delay = 0.15
		}))

		pad_actions:add_action(ACTIONS.TweenGui.new_noctx({
			object = self.vh.tooltip.mobile.pointer_pad, property = "color",
			to = CONSTANTS.COLORS.EMPTY, time = 0.2, easing = TWEEN.easing.outCubic, delay = 0.25
		}))

		pad_actions:add_action(ACTIONS.Function.new(function ()
			create_sequence()
		end))

		self.actions:add_action(pad_actions)
	end
	create_sequence()
end

function Script:hide_tooltip_input()
	if gui.is_enabled(self.vh.tooltip.pc.keys.root) then
		gui.animate(self.vh.tooltip.pc.keys.root, "color.w", 0, gui.EASING_OUTQUAD, 2.5, 0, function ()
			gui.cancel_animations(self.vh.tooltip.pc.keys.root, "scale")
			gui.set_enabled(self.vh.tooltip.pc.keys.root, false)
		end, gui.PLAYBACK_ONCE_FORWARD)
	end
	if gui.is_enabled(self.vh.tooltip.mobile.pointer_pad) then
		gui.animate(self.vh.tooltip.mobile.pointer_pad, "color.w", 0, gui.EASING_OUTQUAD, 2.5, 0, function ()
			gui.set_enabled(self.vh.tooltip.mobile.pointer_pad, false)
		end, gui.PLAYBACK_ONCE_FORWARD)
	end
	self.views.virtual_pad.first_input = true
	self.views.virtual_pad.always_visible_before_first_input = false
	if not self.views.virtual_pad.touch_id then
		self.views.virtual_pad:reset()
	end
end

function Script:hide_tooltip_mouse()
	if gui.is_enabled(self.vh.tooltip.pc.mouse.root) then
		gui.animate(self.vh.tooltip.pc.mouse.root, "color.w", 0, gui.EASING_OUTQUAD, 5, 1, function ()
			gui.cancel_animations(self.vh.tooltip.pc.mouse.root, "scale")
			gui.set_enabled(self.vh.tooltip.pc.mouse.root, false)
			self.pointer_mover = nil
		end, gui.PLAYBACK_ONCE_FORWARD)
	end
	if gui.is_enabled(self.vh.tooltip.mobile.pointer_camera_root) then
		gui.animate(self.vh.tooltip.mobile.pointer_camera_root, "color.w", 0, gui.EASING_OUTQUAD, 5, 0, function ()
			self.pointer_mover = nil
			gui.set_enabled(self.vh.tooltip.mobile.pointer_camera_root, false)
		end, gui.PLAYBACK_ONCE_FORWARD)
	end
end

function Script:init_gui()
	BaseGuiScript.init_gui(self)
	gui.set_render_order(CONSTANTS.GUI_ORDER.GAME)

	self.actions = ACTIONS.Parallel.new(false)
	self.actions.drop_empty = false
	self.current_interact_zone = nil
	self:set_interact_zone(nil, true)

	self.gui_resizer:add_node(self.vh.top_left, 3, { top = 0, left = 0 })
	self.gui_resizer:add_node(self.vh.top, 3, { top = 0 })
	self.gui_resizer:add_node(self.vh.top_right, 2, { top = 0, right = 0 })
	self.gui_resizer:add_node(self.vh.left, 4, { left = 0 })
	self.gui_resizer:add_node(self.vh.right, 3, { right = 0 })
	self.gui_resizer:add_node(self.vh.bottom_left, 3, { bottom = 0, left = 0 })
	self.gui_resizer:add_node(self.vh.bottom, 3, { bottom = 0 })
	self.gui_resizer:add_node(self.vh.bottom_right, 2, { bottom = 0, right = 0 })
	self.gui_resizer:add_node(gui.get_node("resources/root"), 5, { bottom = 0, right = 0 })
	self.gui_resizer:add_node(gui.get_node("resource_list/root"), 5, { bottom = 0, right = 0 })
	self.views.btn_settings:set_input_on_pressed(true)
	self.views.btn_settings:set_input_listener(function ()
		SM:show(SM.MODALS.SETTINGS)
	end)

	for _, pointer in pairs(self.vh.pointers) do
		local scale = gui.get_scale(pointer)
		gui.animate(pointer, "scale", scale * 1.2, gui.EASING_INOUTBACK, 1.25, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
		gui.set_enabled(pointer, false)
	end


	--self.views.virtual_pad:set_enabled(CONSTANTS.IS_MOBILE_DEVICE)
	--self.views.virtual_pad:visible_set(CONSTANTS.IS_MOBILE_DEVICE)

	self:show_tooltip_input()

	self.views.btn_build:set_input_listener(function ()
		GAME:input_build()
	end)

	self.views.btn_remove:set_input_listener(function ()
		GAME:input_remove()
	end)


	self.views.btn_rebirth:set_input_listener(function ()
		SM:show(SM.MODALS.REBIRTH)
	end)
	self.views.btn_pets:set_input_listener(function ()
		SM:show(SM.MODALS.PETS_INVENTORY)
	end)

	self.views.btn_ore:set_input_listener(function ()
		SM:show(SM.MODALS.ORE_INVENTORY)
	end)

	self.views.btn_upgrade:set_input_listener(function ()
		SM:show(SM.MODALS.UPGRADE)
	end)

	self.views.btn_islands:set_input_listener(function ()
		SM:show(SM.MODALS.ISLANDS)
	end)



	self.views.btn_ore:set_input_on_pressed(true)
	self.views.btn_rebirth:set_input_on_pressed(true)
	self.views.btn_pets:set_input_on_pressed(true)
	self.views.btn_islands:set_input_on_pressed(true)


	self.views.virtual_pad.fixed_position = false
	self.views.virtual_pad.always_visible = false
	self.views.virtual_pad.always_visible_before_first_input = true

	self.views.task:set_id(STORAGE.task:get_id())

	gui.set_enabled(self.vh.offer, false)

	gui.set_enabled(gui.get_node("notification_drill_unlocked/root"), false)
	gui.set_enabled(gui.get_node("notification_ore_unlocked/root"), false)
	gui.set_enabled(gui.get_node("cell_resource/root"), false)

	EVENTS.ORE_ADD:subscribe(true, function (_, id, value)
		self.views.ore_list:add_ore(id, value)
		if STORAGE.notifications:is_ore_shown(id) then return end
		STORAGE.notifications:ore_unlocked(id)
		self:ore_unlocked_notification(id)
	end)

	if not CONSTANTS.IS_MOBILE_DEVICE then
		self.views.virtual_pad.position_initial.x = 960 / 2 - 100
		self.views.virtual_pad.position_initial.y = 0
		gui.set_position(self.views.virtual_pad.vh.anchor, self.views.virtual_pad.position_initial)
	end

	for _, v in ipairs(self.pc_input_tooltips) do
		gui.set_enabled(v, not CONSTANTS.IS_MOBILE_DEVICE)
	end

	self.views.mode_toggle:update(GAME.state.build_mode.enable, true)
	self:update_progression_locks()

	self.player_level = {
		level = STORAGE.game:get_level(),
		exp = STORAGE.game:get_exp(),
		exp_next_level = STORAGE.game:get_exp_next_level(),
	}
	self.views.btn_upgrade_progress:set_value_max(self.player_level.exp_next_level)
	self.views.btn_upgrade_progress:set_value(self.player_level.exp, true)
	gui.set_text(self.views.btn_upgrade_progress_label, LOCALIZATION:translate("level", { value = self.player_level.level }))
end

function Script:update_progression_locks()
	self.views.btn_islands:set_enabled(STORAGE.upgrades:get_upgrade_level(DEFS.UPGRADES.BY_ID.UNLOCK_ISLANDS.id) > 0)
	gui.set_enabled(self.views.mode_toggle.vh.root, STORAGE.upgrades:get_upgrade_level(DEFS.UPGRADES.BY_ID.BUILDING.id) > 0)

	local upgrades_available = STORAGE.game:get_level() > 1
	local btn_upgrade_icon = gui.get_node("btn_upgrade/icon")
	local border_node = self.vh.btn_upgrade_border
	local bg_node = self.vh.btn_upgrade_bg
	if upgrades_available then
		gui.reset_material(btn_upgrade_icon)
		self.views.btn_upgrade:set_ignore_input(false)
		gui.set_color(border_node, BTN_UPGRADE_BORDER_COLOR)
		gui.set_color(bg_node, BTN_UPGRADE_BG_COLOR)
	else
		gui.set_color(border_node, BTN_UPGRADE_BORDER_DISABLED_COLOR)
		gui.set_color(bg_node, BTN_UPGRADE_BG_DISABLED_COLOR)
		gui.set_material(btn_upgrade_icon, MATERIAL_GUI_DARKER)
		self.views.btn_upgrade:set_ignore_input(true)
	end
end

function Script:update_tutorial_pointers()
	gui.set_enabled(self.vh.pointers.btn_upgrade, GAME.state.tutorial.pointer_on_upgrade)
	gui.set_enabled(self.vh.pointers.btn_islands, GAME.state.tutorial.pointer_on_islands)
	gui.set_enabled(self.vh.pointers.btn_mode, GAME.state.tutorial.pointer_on_mode_build or GAME.state.tutorial.pointer_on_mode_grind)
	gui.set_enabled(self.vh.pointers.btn_build, GAME.state.tutorial.pointer_on_build_button)
end

function Script:on_input(action_id, action)
	if (self.views.btn_settings:on_input(action_id, action)) then
		self.views.virtual_pad:reset()
		return true
	end

	local consumed = false
	if (self.views.btn_build:on_input(action_id, action)) then
		consumed = true
	end
	if (self.views.mode_toggle:on_input(action_id, action)) then
		return true
	end
	if (self.views.btn_remove:on_input(action_id, action)) then
		consumed = true
	end
	if (self.views.btn_rebirth:on_input(action_id, action)) then
		consumed = true
	end
	if (self.views.btn_pets:on_input(action_id, action)) then
		consumed = true
	end
	if (self.views.btn_ore:on_input(action_id, action)) then
		consumed = true
	end

	if (self.views.btn_upgrade:on_input(action_id, action)) then
		consumed = true
	end
	if (self.views.btn_islands:on_input(action_id, action)) then
		consumed = true
	end
	self.views.virtual_pad:set_blocked_touch(self.views.btn_build.clickable.touch_id
		or self.views.btn_remove.clickable.touch_id or
		self.views.btn_rebirth.clickable.touch_id or self.views.btn_pets.clickable.touch_id or
		self.views.btn_islands.clickable.touch_id)
	if consumed then return true end

	if action_id == HASH.INPUT.TOUCH or action_id == HASH.INPUT.TOUCH_MULTI then
		if self.views.virtual_pad:on_input() then return true end
	end


	if (self.views.btn_zoom_minus:on_input(action_id, action)) then return true end
	if (self.views.btn_zoom_plus:on_input(action_id, action)) then return true end


	if self.offer and self.offer:on_input(action_id, action) then
		self.views.virtual_pad:reset()
		return true
	end
end

function Script:update(dt)
	self.actions:update(dt)
	self.views.virtual_pad:update(dt)
	self.views.task:update(dt)
	self.views.btn_rebirth_progress:update(dt)
	self.views.powerup_pickaxe_gold_view:update()
	self.views.powerup_pickaxe_gold_view:update()
	self.views.ore_list:update(dt)
	self.views.resource_list:update(dt)
	self.views.build_selected_info:update()
	self:update_tutorial_pointers()
	if SM:get_top() and SM:get_top()._name ~= SM.SCENES.GAME or SM:is_working() then
		self.views.virtual_pad:reset()
	end
	self.views.btn_build:set_enabled(GAME.state.build_mode.can_build)

	local can_remove = false
	local level_creator = GAME.level_creator
	if GAME.state.build_mode.enable and level_creator and level_creator.player then
		local interact = level_creator.player.current_interact_aabb_look or level_creator.player.current_interact_aabb
		can_remove = interact ~= nil and interact.buildable ~= nil
	end
	self.views.btn_remove:set_enabled(can_remove)
	self.views.mode_toggle:update(GAME.state.build_mode.enable)

	if (self.offer and self.offer.vh == nil) then
		self.offer = nil
	end

	if self.views.btn_zoom_minus:is_enabled() then
		local zoom = STORAGE.options:zoom_get()
		if self.views.btn_zoom_minus.clickable.pressed then
			zoom = math.min(zoom + 0.5 * dt, 1)
			STORAGE.options:zoom_set(zoom)
		end
		if self.views.btn_zoom_plus.clickable.pressed then
			zoom = math.max(zoom - 0.5 * dt, 0)
			STORAGE.options:zoom_set(zoom)
		end
	end


	if #self.notifications > 0 then
		local notification = self.notifications[1]
		local notification_dt = dt
		if self.notifications[3] then
			notification_dt = notification_dt * 3
		elseif self.notifications[2] then
			notification_dt = notification_dt * 2
		end
		notification:update(notification_dt)
		if not notification.vh then
			table.remove(self.notifications, 1)
		end
	end

	if #self.notifications_ore > 0 then
		local notification = self.notifications_ore[1]
		local notification_dt = dt
		if self.notifications_ore[3] then
			notification_dt = notification_dt * 1.5
		elseif self.notifications_ore[2] then
			notification_dt = notification_dt * 1.25
		end
		notification:update(notification_dt)
		if not notification.vh then
			table.remove(self.notifications_ore, 1)
		end
	end

	self.views.btn_upgrade_progress:update(dt)
	self.views.btn_upgrade_progress:set_value(self.player_level.exp)
	if STORAGE.game:can_level_up() and self.views.btn_upgrade_progress:is_full() and not self.player_level.level_up_action then
		STORAGE.game:level_up()
		self.player_level.exp = 0
		self.player_level.level = STORAGE.game:get_level()
		self.player_level.level_up_action = ACTIONS.Sequence.new(false)
		gui.set_text(self.views.btn_upgrade_progress_label, LOCALIZATION:translate("level", { value = self.player_level.level }))
		local scale = vmath.vector3(0.55)
		self.views.btn_upgrade_progress:set_value(0)
			self.player_level.level_up_action:add_action(ACTIONS.TweenGui.new_noctx({
			object = self.views.btn_upgrade_progress.vh.root, property = "scale",
			from = scale, to = scale*1.25, time = 0.33, delay = 0.1,
			easing = TWEEN.easing.inOutBounce
		}))
		self.player_level.level_up_action:add_action(ACTIONS.TweenGui.new_noctx({
			object = self.views.btn_upgrade_progress.vh.root, property = "scale",
			from = scale * 1.25, to = scale, time = 0.33, delay = 0.1,
			easing = TWEEN.easing.inOutBounce
		}))
	end
	if not self.player_level.level_up_action then
		self.player_level.exp = STORAGE.game:get_exp()
	end
end

function Script:on_resize()
	BaseGuiScript.on_resize(self)

	self.views.virtual_pad:on_resize()
	self.views.virtual_pad:reset()

	if RENDER.screen_size.aspect > 1 then
		--	self.views.virtual_pad.fixed_position = false
		--	self.views.virtual_pad.always_visible = true
		self.views.virtual_pad:set_borders(0, 0, RENDER.screen_size.w * 1, RENDER.screen_size.h * 0.7)
		self.views.virtual_pad:set_borders_2(0, 0, 0, 0)
		gui.set_position(self.views.btn_rebirth.root, vmath.vector3(50, 100, 0))
		gui.set_position(self.views.btn_upgrade.root, vmath.vector3(50, 100, 0))
		gui.set_position(self.views.btn_ore.root, vmath.vector3(50, 0, 0))
		gui.set_position(self.views.btn_islands.root, vmath.vector3(50, 0, 0))
		gui.set_position(self.views.btn_pets.root, vmath.vector3(50, -100, 0))
		gui.set_parent(self.views.btn_build.root, self.vh.bottom)
		gui.set_parent(self.views.btn_remove.root, self.vh.bottom)
		gui.set_position(self.views.btn_build.root, vmath.vector3(58, 140, 0))
		gui.set_position(self.views.btn_remove.root, vmath.vector3(-58, 140, 0))
		--	self.views.virtual_pad.fixed_position = false
		--	self.views.virtual_pad.always_visible = true
		self.views.virtual_pad:set_borders(0, 0, RENDER.screen_size.w * 1, RENDER.screen_size.h * 0.7)
		self.views.virtual_pad:set_borders_2(0, 0, 0, 0)
	else
		gui.set_parent(self.views.btn_build.root, self.vh.bottom_right)
		gui.set_parent(self.views.btn_remove.root, self.vh.bottom_right)
		gui.set_position(self.views.btn_rebirth.root, vmath.vector3(125, 120, 0))
		gui.set_position(self.views.btn_upgrade.root, vmath.vector3(50, 120, 0))
		gui.set_position(self.views.btn_ore.root, vmath.vector3(125, 20, 0))
		gui.set_position(self.views.btn_islands.root, vmath.vector3(50, 20, 0))
		gui.set_position(self.views.btn_pets.root, vmath.vector3(125, -80, 0))
		gui.set_position(self.views.btn_build.root, vmath.vector3(-55, 55, 0))
		gui.set_position(self.views.btn_remove.root, vmath.vector3(-150, 55, 0))
	end
	self.views.mode_toggle:on_resize()
	self.views.mode_toggle:update(GAME.state.build_mode.enable, true)

	for i = 1, #self.notifications do
		local notification = self.notifications[i]
		notification:on_resize()
	end

	for i = 1, #self.notifications_ore do
		local notification = self.notifications_ore[i]
		notification:on_resize()
	end
end

function Script:on_storage_changed()
	self:set_interact_zone(self.current_interact_zone, true)
	self.views.task:on_storage_changed()

	self.views.btn_rebirth:set_enabled(false)
	self.views.btn_ore:set_enabled(false)
	self.views.btn_pets:set_enabled(false)


	local next_rebirth = STORAGE.game:get_rebirth().rebirth + 1
	local next_rebirth_def = DEFS.REBIRTH[next_rebirth]
	if next_rebirth_def then
		self.views.btn_rebirth_progress:set_value_max(next_rebirth_def.ore_target)
		self.views.btn_rebirth_progress:set_enabled(true)
		self.views.btn_rebirth_progress:set_value(STORAGE.game:get_rebirth().ore_drilled)
		gui.set_enabled(self.vh.btn_rebirth_glow, self.views.btn_rebirth_progress.animation.value >=
			self.views.btn_rebirth_progress.value_max)
	else
		self.views.btn_rebirth_progress:set_enabled(false)
		gui.set_enabled(self.vh.btn_rebirth_glow, false)
	end
	self:update_progression_locks()
end

function Script:on_language_changed()
	self.views.btn_rebirth_lbl:set_text(LOCALIZATION:translate("btn_rebirth"))
	self.views.btn_pets_lbl:set_text(LOCALIZATION:translate("btn_pets"))
	self.views.btn_islands_lbl:set_text(LOCALIZATION:translate("btn_islands"))
	self.views.btn_upgrade_lbl:set_text(LOCALIZATION:translate("btn_upgrades"))
	self.views.btn_ore_lbl:set_text(LOCALIZATION:translate("btn_ore"))
	self.views.btn_remove_lbl:set_text(LOCALIZATION:translate("btn_remove"))
	self.views.btn_build_lbl:set_text(LOCALIZATION:translate("btn_build"))
	if self.views.build_selected_info then
		self.views.build_selected_info:on_language_changed()
	end
	if self.views.mode_toggle then
		self.views.mode_toggle:on_localization_changed()
	end
end

function Script:set_game_mode(is_build_mode)
	if is_build_mode and not STORAGE.upgrades:get_upgrade_level(DEFS.UPGRADES.BY_ID.BUILDING.id) > 0 then
		is_build_mode = false
	end
	if GAME.state.build_mode.enable == is_build_mode then
		return
	end
	GAME.state.build_mode.enable = is_build_mode
	if not is_build_mode then
		GAME.state.build_mode.build_pressed = false
		GAME.state.build_mode.remove_pressed = false
	end
	self.views.mode_toggle:update(GAME.state.build_mode.enable, true)
end

function Script:set_interact_zone(zone, forced)
	--[[	if zone and (zone.object_config and (zone.object_config.type == DEFS.OBJECTS.TYPES.OBJECT.OBJECTS.ADS_ATM_X2_MONEY.id
			or zone.object_config.type == DEFS.OBJECTS.TYPES.OBJECT.OBJECTS.ADS_MONEY.id or zone.object_config.type == DEFS.OBJECTS.TYPES.OBJECT.OBJECTS.ADS_BALLOON_OBBY_TOWER.id)) then
		forced = true
		--need check button and timer
	end--]]
	if self.current_interact_zone ~= zone or forced then
		self.current_interact_zone = zone
	end
end

---@return OfferView
function Script:create_offer()
	assert(not self.offer)
	local nodes = gui.clone_tree(self.vh.offer)
	self.offer = OfferView.new(nodes)
	return self.offer
end

function Script:drill_unlocked_notification(drill)
	local notification = Notification.new()
	local def = DEFS.DRILLS.BY_ID[drill]
	notification:set_text(def.title)
	notification:set_icon(def.icon)
	notification:animate()
	table.insert(self.notifications, notification)
end

function Script:ore_unlocked_notification(id)
	local notification = NotificationOre.new()
	notification:set_ore(id)
	notification:animate()
	table.insert(self.notifications_ore, notification)
end

N28S.register(CLASS.new_instance(Script))
